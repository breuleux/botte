
require:
   fs
   irc
   moment
   .source ->
      StreamSource
   .utilities ->
      get-network as extract-network
      get-channel as extract-channel
   commander


method here-command(mthd, cmd, argument, channel, m) =
   @client[mthd](channel, argument)
   @fudge with {
      type = cmd
      channel = channel
      agent = @client.nick
      content = argument
   }

method chanarg-command(mthd, cmd, argument, m) =
   {channel, *text} = argument.split(" ")
   content = text.join(" ")
   @client[mthd](channel, content)
   @fudge with {
      type = cmd
      channel = channel
      agent = @client.nick
      content = content
   }

commands = {

   method say(argument, channel, m) =
      here-command.call(@, .say, .message, argument, channel, m)

   method me(argument, channel, m) =
      here-command.call(@, .action, .action, argument, channel, m)

   method message(argument, _, m) =
      chanarg-command.call(@, .say, .message, argument, m)

   method notice(argument, _, m) =
      chanarg-command.call(@, .notice, .notice, argument, m)

   method action(argument, _, m) =
      chanarg-command.call(@, .action, .action, argument, m)

   method join(argument, _, m) =
      @client.join(argument)
      null

   method part(argument, channel, m) =
      @client.part(argument or channel)
      null

   method nick(argument, _, m) =
      @client.send(.nick, argument)
      null

   method send(argument, _, m) =
      @client.send(*argument.split(" "))
      null

   method _other(argument, channel, m) =
      @fudge with {
         type = .unknown-command
         channel = channel
         command = m.command
         argument = m.argument
      }

}

command-aliases = {
   msg = "message"
   j = "join"
   ns = "message NickServ"
   cs = "message ChanServ"
   broo = "message Broolucks"
}


events = {

   method registered(m) =
      ;; {
      ;;    type = .nick
      ;;    channel = ""
      ;;    from = null
      ;;    to = m.args[0]
      ;; }
      @client.say("NickServ", 'id {@nickserv-password}')
      {
         type = .join
         channel = ""
         agent = @client.nick ;; m.args[0]
         self = true
      }

   method motd(text) = {
      type = .motd
      channel = ""
      content = text
   }

   method names(channel, nicks) = {
      type = .names
      = channel
      content = object with items(nicks) each {nick, level} ->
         {nick, {operator-level = level}}
   }

   method topic(channel, topic, agent, message) = {
      type = .topic
      = channel, = agent
      content = topic
   }

   method join(channel, agent, m) = {
      type = .join
      = channel, = agent
      self = agent === @client.nick
   }

   method part(channel, agent, m) = {
      type = .part
      = channel, = agent
      self = agent === @client.nick
   }

   method quit(agent, reason, channels, m) =
      channels each channel -> {
         type = .quit
         = channel, = agent
         content = reason
      }

   method kick(channel, nick, agent, reason, m) = {
      type = .kick
      = channel, = agent
      kicked = nick
      content = reason
   }

   method kill(agent, reason, channels, m) =
      channels each channel -> {
         type = .kill
         = channel, = agent
         content = reason
      }

   method message(agent, channel, text, _) =
      m = @fudge with {
         type = .message
         = channel, = agent
         content = text
      }
      if m.channel === m.agent and not @pms.has(m.agent):
         @pms.add(m.agent)
         j = {
            type = .join
            channel = m.agent
            agent = @client.nick
            self = true
         }
         n = {
            type = .names
            channel = m.agent
            content = {
               m.agent => {operator-level = ""}
               @client.nick => {operator-level = ""}
            }
         }
         {j, n, m}
      else:
         m

   ;; method selfMessage(*args) =
   ;;    @unhandled('selfMessage', args)

   method notice(agent, channel, text, m) = @fudge with {
      type = .notice
      = channel, = agent
      content = text
   }

   ;; method ping(*args) =
   ;;    @unhandled('ping', args)

   ;; method pm(*args) =
   ;;    @unhandled('pm', args)

   method ctcp(*args) =
      @unhandled('ctcp', args)

   method ctcp-notice(*args) =
      @unhandled('ctcp-notice', args)

   method ctcp-privmsg(*args) =
      @unhandled('ctcp-privmsg', args)

   method ctcp-version(*args) =
      @unhandled('ctcp-version', args)

   method nick(oldnick, newnick, channels, m) =
      if not oldnick or oldnick === @nickname:
         @nickname = newnick
      (channels ++ {oldnick}) each channel -> {
         type = .nick
         = channel
         from = oldnick
         to = newnick
      }

   method invite(*args) =
      @unhandled('invite', args)

   method "+mode"(channel, by, mode, argument, m) = {
      type = .add-mode
      = channel, agent = by
      = mode
      = argument
   }

   method "-mode"(channel, by, mode, argument, m) = {
      type = .remove-mode
      = channel, agent = by
      = mode
      = argument
   }

   method whois(*args) =
      @unhandled('whois', args)

   method channellist_start(*args) =
      @unhandled('channellist_start', args)

   method channellist_item(*args) =
      @unhandled('channellist_item', args)

   method channellist(*args) =
      @unhandled('channellist', args)

   method raw(*args) =
      pass

   method error(*args) =
      @unhandled('error', args)

   method action(*args) =
      @unhandled('action', args)
}


class IRCClient:

   constructor(@network, @settings) =
      ;; @in-stream = StreamSource(in-stream, null)
      @settings as {
         nickname => @nickname
         => channels
         => user-name
         => real-name
         nickserv-password => @nickserv-password
      }
      @network-prefix = 'irc://{@network}'
      @client = new irc.Client(@network, @nickname) with {
         = user-name
         = real-name
         = channels
      }
      @pms = new Set()
      @install-handlers()

   fudge(m) =
      if not m.agent:
         m.agent = m.channel
         m.channel = ""
      if m.channel === @nickname:
         m.channel = m.agent
      m

   augment(message) =
      message.channel = '{@network-prefix}/{ch.replace(R.g"/", "\\/")}' where
         ch = message.channel or ""
      message.format = "irc"
      message.time = moment().format("YYYY-MM-DD HH:mm:ss")
      message

   unhandled(m, args) =
      {
         type = .unhandled
         channel = m.channel or ""
         message-type = m
         content = args
      }

   print-result(result) =
      if result:
         (Array! result) each entry ->
            print JSON.stringify(@augment(entry), null, 2)

   install-handlers() =
      items(events) each {k, fn} ->
         @client.add-listener(k) with {*args} ->
            @print-result(fn.call(@, *args))

   process-message(message) =
      channel = extract-channel(message.channel)
      var cmd = message.command.to-lower-case()
      if command-aliases[cmd] as alias:
         {cmd, *args} = alias.split(" ")
         message.command = cmd
         message.argument = (args ++ {message.argument}).join(" ")
      fn = commands[cmd] or commands._other
      result = fn.call(@, message.argument, channel, message)
      @print-result(result)


class Dispatcher:

   constructor(in-stream, configurations, @defaults) =
      @in-stream = StreamSource(in-stream, null)
      @networks = {=}
      @configurations = {=}
      @aliases = {=}
      items(configurations or {=}) each {alias, cfg} ->
         url = cfg.url or alias
         if url !== alias:
            @aliases[alias] = url
         R"irc://(.*)"! {_, cfg.irc-address} = cfg.url
         @configurations[url] = cfg

   get-configuration(name) =
      if @aliases[name] as real-name:
         return @get-configuration(real-name)
      return @defaults & (@configurations[name] or {=})

   get-network(name) =
      cfg = @get-configuration(name)
      if @networks[cfg.url] as rval:
         return rval
      nw = IRCClient(cfg.irc-address) with {
         nickname = cfg.nicknames[0]
         channels = {}
         user-name = cfg.user-name
         real-name = cfg.real-name
         nickserv-password = cfg.password
      }
      @networks[cfg.url] = nw
      nw

   connect(network, channels = {}) =
      cfg = @get-configuration(network)
      if @networks[cfg.url]:
         throw E.already-connected(network)
      nw = IRCClient(cfg.irc-address) with {
         nickname = cfg.nicknames[0]
         = channels
         user-name = cfg.user-name
         real-name = cfg.real-name
         nickserv-password = cfg.password
      }
      @networks[cfg.url] = nw
      nw      

   async run() =
      while true:
         message = await @in-stream.next()
         if not message:
            return
         network-name = extract-network(message.channel)
         network = @get-network(network-name)
         network.process-message(message)




async main() =

   cli-options =
      chain commander:
        @version('0.0.1')
        @option('-s, --settings [file]', 'File defining the settings.')
        @parse(process.argv)

   settings = JSON.parse(fs.read-file-sync(cli-options.settings, .utf8))

   d = Dispatcher(process.stdin, settings.networks, settings.network-defaults)

   if settings.join-groups:
      connections = {=}
      items(settings.client.groups) each {name, channels} ->
         channels each channel ->
            ch = extract-channel(channel)
            nw = extract-network(channel)
            (connections[nw] or= {}).push(ch)
      items(connections) each {nw, channels} ->
         d.connect(nw, channels)

   d.run()

async: main()
