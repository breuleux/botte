
require:
   react-dom as ReactDOM
   color-space -> lchab
   md5
   moment
   .mixins ->
      MasterEvents
      ViewEvents
      ShardEvents
      ShardsetEvents
      PureRender
      DebouncedTasks
   ..utilities ->
      shorten
      SortedArray
   .links ->
      expand-links
   ..renderers ->
      message-renderers
   ;; ..shard ->
   ;;    Shards

require-macros:
   earl-react ->
      %, component

provide:
   Message
   ;; Messages
   ;; Messages2
   ShardsetComponent
   ShardComponent

color-cache = {=}

component Message:
   colorize-name(s) =
      color =
         if color-cache[s] as cached:
            cached
         else:
            hash = md5(s)
            lig = 50
            sat = 100
            hue = 360 * parse-int(hash[0...2], 16)/256
            c = lchab.rgb({lig, sat, hue}) each v -> Math.floor(v)
            colstring = 'rgb({c[0]}, {c[1]}, {c[2]})'
            color-cache[s] = colstring
            colstring
      span %
         style = {color = color, font-weight = .bold}
         s
   show-message(channel, agent, content, extra-class = "") =
      .message %
         class-name = extra-class
         .message-channel % shorten(channel)
         .message-source % if{@props.active, @colorize-name(agent), agent}
         .message-content %
            match content:
               String? -> expand-links(content)
               else -> content
   status-message(channel, content) =
      .message %
         .message-channel % shorten(channel)
         .message-source % ""
         .message-content % content
   render() =
      r = message-renderers[@props.message.type]
          \ or message-renderers._unhandled
      try:
         r.call(@, @props.message) or (span % "")
      catch e:
         .message.error %
            .message-source.error % "!RERROR!"
            .message-content %
               div % e.message
               div % JSON.stringify(@props.message, true, 2)



;; component Messages:
;;    mixins = {ViewEvents}

;;    get-initial-state() = {
;;       messages = @populate(@props.view.messages)
;;       active-channel = @props.view.active-channel
;;       now = moment()
;;    }

;;    populate(messages) =
;;       s = SortedArray(___, false) with m -> m.start-time + " " + m.seq-id
;;       s.populate(messages)

;;    component-will-update() =
;;       node = ReactDOM.findDOMNode(@)
;;       @at-bottom = (node.scrollTop + node.offsetHeight) >= node.scrollHeight

;;    component-did-update() =
;;       if @at-bottom:
;;          node = ReactDOM.findDOMNode(@)
;;          node.scrollTop = node.scrollHeight

;;    view-events() = {
;;       ;; tick() =
;;       ;;    @set-state with {
;;       ;;       now = moment()
;;       ;;    }

;;       set-active-channel(ch) =
;;          @set-state with {
;;             active-channel = ch
;;          }

;;       add-message(m) =
;;          @set-state with {
;;             messages = @state.messages.add(m)
;;          }
      
;;       delete-message(m) =
;;          @set-state with {
;;             messages = @state.messages.delete(m)
;;          }

;;       error(channel, msg, error) =
;;          @set-state with {
;;             messages = @state.messages ++ {err} where err = {
;;                type = .error
;;                message = msg
;;                error = error
;;             }
;;          }
;;    }

;;    render() =
;;       var prev = null
;;       .messages %
;;          @state.messages each m ->
;;             active = m.channel === @props.view.active-channel
;;             result =
;;                div %
;;                   className = if{active, "active-message", "inactive-message"}
;;                   ;; if prev and false:
;;                   ;;    Intercalary %
;;                   ;;       threshold = 5
;;                   ;;       message1 = prev
;;                   ;;       message2 = m
;;                   Message %
;;                      key = m.message-id
;;                      active = active
;;                      message = m
;;             prev = m
;;             result
;;          ;; if prev and false:
;;          ;;    Intercalary %
;;          ;;       threshold = 5
;;          ;;       message1 = prev
;;          ;;       message2 = {time = @state.now}

;;       ;; var prev = null
;;       ;; .messages %
;;       ;;    @state.messages each m ->
;;       ;;       curr = mom(m.time)
;;       ;;       diff = if{prev, Math.abs(prev.diff(curr)), 0}
;;       ;;       prev = curr
;;       ;;       result = Message %
;;       ;;          key = m.message-id
;;       ;;          master = @props.master
;;       ;;          message = m
;;       ;;       if diff > 5000:
;;       ;;          div %
;;       ;;             .inactivity-period %
;;       ;;                String{'{diff // 1000} seconds of inactivity'}
;;       ;;             result
;;       ;;       else:
;;       ;;          result
;;       ;;    do:
;;       ;;       diff = Math.abs(prev.diff(moment()))
;;       ;;       if diff > 5000:
;;       ;;          .inactivity-period %
;;       ;;             String{'{diff // 1000} seconds of inactivity'}
;;       ;;       else:
;;       ;;          ""







MessageArray(messages) =
   s = SortedArray(___, false) with
      m -> m.start-time + " " + m.seq-id
   s.populate(messages)



component ShardsetComponent:
   mixins = {ViewEvents, ShardsetEvents, PureRender, DebouncedTasks}

   get-initial-state() =
      @at-bottom = true
      {
         ;; focus = @props.view.focus??.full-name
         shards = clone(@props.shardset.parts)
      }

   ;; prepare-scroll-change() =
   ;;    node = ReactDOM.findDOMNode(@)
   ;;    @at-bottom = (node.scrollTop + node.offsetHeight) >= node.scrollHeight

   update-scroll() =
      if @at-bottom:
         node = ReactDOM.findDOMNode(@)
         node.scrollTop = node.scrollHeight

   ;; component-will-update() =
   ;;    @prepare-scroll-change()

   component-did-update() =
      @update-scroll()

   view-events() = {
      ;; prepare-scroll-change() =
      ;;    ;; @prepare-scroll-change()
      ;;    @at-bottom = true
      scroll-change() =
         @update-scroll()
      ;; add-messages(ms) =
      ;;    @props.shardset.add-all(ms)
      ;; delete-messages(ms) =
      ;;    @props.shardset.delete-all(ms)
   }

   shardset-events() = {
      add-shard(shard, index) =
         ;; print 'Adding a shard at {index} for {@props.view.label}'
         shards = clone(@state.shards)
         shards.splice(index, 0, shard)
         @set-state with {shards = shards}
      delete-shard(shard, index) =
         throw E.not-implemented()
   }

   render() =
      ;; print 'render the {@state.shards.length} shards'
      .messages %
         on-scroll() =
            node = ReactDOM.findDOMNode(@)
            @at-bottom = (node.scrollTop + node.offsetHeight) >= node.scrollHeight
         @state.shards each shard ->
            ShardComponent %
               key = shard.id
               shard = shard
               view = @props.view
               master = @props.master


component ShardComponent:
   mixins = {ShardEvents, ViewEvents, MasterEvents, DebouncedTasks}

   get-initial-state() = {
      focus = @props.view.focus??.full-name
      messages = MessageArray({}).populate(@props.shard.elements._arr)
   }

   execute-tasks(tasks) =
      to-add = {}
      to-delete = {}
      new-state = {=}
      tasks each
         #add{m} ->
            to-add.push(m)
         #delete{m} ->
            to-delete.push(m)
         #focus{name} ->
            new-state.focus = name
      if to-add.length > 0:
         new-state.messages = @state.messages.add-all(to-add)
      if to-delete.length > 0:
         new-state.messages = (new-state.messages or @state.messages).delete-all(to-delete)
      if new-state != {=}:
         @set-state(new-state)

   ;; component-will-update() =
   ;;    @props.view.emit(.prepare-scroll-change)

   component-did-update() =
      @props.view.emit(.scroll-change)

   master-events() = {
      unattached-message(m) =
         if @props.master.focus === @props.view
            \ and (not @props.shard.max or m.start-time < @props.shard.max)
            \ and (not @props.shard.min or m.start-time >= @props.shard.min):
            @do-task(#add{m})
   }

   view-events() = {
      set-focus(_, channel) =
         @do-task(#focus{channel??.full-name})
         ;; @set-state with {focus = channel??.full-name}
   }

   shard-events() = {
      add-element(m) =
         ;; @set-state with {messages = @state.messages.add(m)}
         @do-task(#add{m})
      delete-element(m) =
         ;; @set-state with {messages = @state.messages.delete(m)}
         @do-task(#delete{m})
   }

   render() =
      .shard %
         @state.messages each m ->
            active = m.channel === @state.focus
            result =
               div %
                  ;; key = m.message-id
                  className = if{active, "active-message", "inactive-message"}
                  Message %
                     active = active
                     message = m
            result


;; component Messages2:
;;    mixins = {ViewEvents}

;;    get-initial-state() = {
;;       focus = @props.view.focus??.full-name
;;       messages = MessageArray({})
;;       ;; MessageArray(@props.view.focus??.messages or {})
;;    }

;;    component-will-update() =
;;       node = ReactDOM.findDOMNode(@)
;;       @at-bottom = (node.scrollTop + node.offsetHeight) >= node.scrollHeight

;;    component-did-update() =
;;       if @at-bottom:
;;          node = ReactDOM.findDOMNode(@)
;;          node.scrollTop = node.scrollHeight

;;    view-events() = {
;;       set-focus(_, channel) =
;;          @set-state with {focus = channel??.full-name}
;;       add-messages(ms) =
;;          @set-state with {messages = @state.messages.add-all(ms)}
;;       delete-messages(ms) =
;;          @set-state with {messages = @state.messages.delete-all(ms)}
;;    }

;;    render() =
;;       .messages %
;;          @state.messages each m ->
;;             active = m.channel === @state.focus
;;             result =
;;                div %
;;                   className = if{active, "active-message", "inactive-message"}
;;                   Message %
;;                      key = m.message-id
;;                      active = active
;;                      message = m
;;             result

;;    ;; get-initial-state() = {
;;    ;;    messages = @populate(@props.view.messages)
;;    ;;    active-channel = @props.view.active-channel
;;    ;;    now = moment()
;;    ;; }

;;    ;; populate(messages) =
;;    ;;    s = SortedArray(___, false) with m -> m.start-time + " " + m.seq-id
;;    ;;    s.populate(messages)

;;    ;; component-will-update() =
;;    ;;    node = ReactDOM.findDOMNode(@)
;;    ;;    @at-bottom = (node.scrollTop + node.offsetHeight) >= node.scrollHeight

;;    ;; component-did-update() =
;;    ;;    if @at-bottom:
;;    ;;       node = ReactDOM.findDOMNode(@)
;;    ;;       node.scrollTop = node.scrollHeight

;;    ;; view-events() = {
;;    ;;    ;; tick() =
;;    ;;    ;;    @set-state with {
;;    ;;    ;;       now = moment()
;;    ;;    ;;    }

;;    ;;    set-active-channel(ch) =
;;    ;;       @set-state with {
;;    ;;          active-channel = ch
;;    ;;       }

;;    ;;    add-message(m) =
;;    ;;       @set-state with {
;;    ;;          messages = @state.messages.add(m)
;;    ;;       }
      
;;    ;;    delete-message(m) =
;;    ;;       @set-state with {
;;    ;;          messages = @state.messages.delete(m)
;;    ;;       }

;;    ;;    error(channel, msg, error) =
;;    ;;       @set-state with {
;;    ;;          messages = @state.messages ++ {err} where err = {
;;    ;;             type = .error
;;    ;;             message = msg
;;    ;;             error = error
;;    ;;          }
;;    ;;       }
;;    ;; }

;;    ;; render() =
;;    ;;    var prev = null
;;    ;;    .messages %
;;    ;;       @state.messages each m ->
;;    ;;          active = m.channel === @props.view.active-channel
;;    ;;          result =
;;    ;;             div %
;;    ;;                className = if{active, "active-message", "inactive-message"}
;;    ;;                ;; if prev and false:
;;    ;;                ;;    Intercalary %
;;    ;;                ;;       threshold = 5
;;    ;;                ;;       message1 = prev
;;    ;;                ;;       message2 = m
;;    ;;                Message %
;;    ;;                   key = m.message-id
;;    ;;                   active = active
;;    ;;                   message = m
;;    ;;          prev = m
;;    ;;          result
;;    ;;       ;; if prev and false:
;;    ;;       ;;    Intercalary %
;;    ;;       ;;       threshold = 5
;;    ;;       ;;       message1 = prev
;;    ;;       ;;       message2 = {time = @state.now}

;;    ;;    ;; var prev = null
;;    ;;    ;; .messages %
;;    ;;    ;;    @state.messages each m ->
;;    ;;    ;;       curr = mom(m.time)
;;    ;;    ;;       diff = if{prev, Math.abs(prev.diff(curr)), 0}
;;    ;;    ;;       prev = curr
;;    ;;    ;;       result = Message %
;;    ;;    ;;          key = m.message-id
;;    ;;    ;;          master = @props.master
;;    ;;    ;;          message = m
;;    ;;    ;;       if diff > 5000:
;;    ;;    ;;          div %
;;    ;;    ;;             .inactivity-period %
;;    ;;    ;;                String{'{diff // 1000} seconds of inactivity'}
;;    ;;    ;;             result
;;    ;;    ;;       else:
;;    ;;    ;;          result
;;    ;;    ;;    do:
;;    ;;    ;;       diff = Math.abs(prev.diff(moment()))
;;    ;;    ;;       if diff > 5000:
;;    ;;    ;;          .inactivity-period %
;;    ;;    ;;             String{'{diff // 1000} seconds of inactivity'}
;;    ;;    ;;       else:
;;    ;;    ;;          ""

