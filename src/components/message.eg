
require:
   react-dom as ReactDOM
   color-space -> lchab
   md5
   moment
   .mixins ->
      MasterEvents
      ViewEvents
      ShardEvents
      ShardsetEvents
      PureRender
      DebouncedTasks
   ..utilities ->
      shorten
      SortedArray
   .links ->
      expand-links
   ..renderers ->
      message-renderers

require-macros:
   earl-react ->
      %, component

provide:
   Message
   ShardsetComponent
   ShardComponent

color-cache = {=}


MessageArray(messages) =
   s = SortedArray with {m1, m2} ->
      t1 = m1.start-time
      t2 = m2.start-time
      s1 = m1.seq-id
      s2 = m2.seq-id
      if t1 < t2:
         -1
      elif t1 > t2:
         1
      elif s1 < s2:
         -1
      elif s1 > s2:
         1
      else:
         0
   s.populate(messages)

component Message:
   colorize-name(s) =
      color =
         if color-cache[s] as cached:
            cached
         else:
            hash = md5(s)
            lig = 50
            sat = 100
            hue = 360 * parse-int(hash[0...2], 16)/256
            c = lchab.rgb({lig, sat, hue}) each v -> Math.floor(v)
            colstring = 'rgb({c[0]}, {c[1]}, {c[2]})'
            color-cache[s] = colstring
            colstring
      span %
         style = {color = color, font-weight = .bold}
         s
   show-message(channel, agent, content, extra-class = "") =
      .message %
         class-name = extra-class
         .message-channel % shorten(channel)
         .message-source % if{@props.active, @colorize-name(agent), agent}
         .message-content %
            match content:
               String? -> expand-links(content)
               else -> content
   status-message(channel, content) =
      .message %
         .message-channel % shorten(channel)
         .message-source % ""
         .message-content % content
   render() =
      r = message-renderers[@props.message.type]
          \ or message-renderers._unhandled
      try:
         r.call(@, @props.message) or (span % "")
      catch e:
         .message.error %
            .message-source.error % "!RERROR!"
            .message-content %
               div % e.message
               div % JSON.stringify(@props.message, true, 2)


component ShardsetComponent:
   mixins = {ViewEvents, ShardsetEvents, PureRender, DebouncedTasks}

   get-initial-state() =
      @at-bottom = true
      {
         shards = clone(@props.shardset.parts)
      }

   update-scroll() =
      if @at-bottom:
         node = ReactDOM.findDOMNode(@)
         node.scrollTop = node.scrollHeight

   component-did-update() =
      @update-scroll()

   view-events() = {
      scroll-change() =
         @update-scroll()
   }

   shardset-events() = {
      add-shard(shard, index) =
         ;; print 'Adding a shard at {index} for {@props.view.label}'
         shards = clone(@state.shards)
         shards.splice(index, 0, shard)
         @set-state with {shards = shards}
      delete-shard(shard, index) =
         throw E.not-implemented()
   }

   render() =
      .messages %
         on-scroll() =
            node = ReactDOM.findDOMNode(@)
            @at-bottom = (node.scrollTop + node.offsetHeight) >= node.scrollHeight
         @state.shards each shard ->
            ShardComponent %
               key = shard.id
               shard = shard
               view = @props.view
               master = @props.master


component ShardComponent:
   mixins = {ShardEvents, ViewEvents, MasterEvents, DebouncedTasks}

   get-initial-state() = {
      focus = @props.view.focus??.full-name
      messages = MessageArray({}).populate(@props.shard.elements._arr)
   }
   
   execute-tasks(tasks) =
      var messages = @state.messages
      new-state = {=}
      tasks each
         #add{m} ->
            messages and new-state.messages = messages.add(m)
         #delete{m} ->
            messages and new-state.messages = messages.delete(m)
         #focus{name} ->
            changes = true
            new-state.focus = name
      if new-state != {=}:
         @set-state(new-state)

   component-did-update() =
      @props.view.emit(.scroll-change)

   master-events() = {
      unattached-message(m) =
         if @props.master.focus === @props.view
            \ and (not @props.shard.max or m.start-time < @props.shard.max)
            \ and (not @props.shard.min or m.start-time >= @props.shard.min):
            @do-task(#add{m})
   }

   view-events() = {
      set-focus(_, channel) =
         @do-task(#focus{channel??.full-name})
   }

   shard-events() = {
      add-element(m) =
         @do-task(#add{m})
      delete-element(m) =
         @do-task(#delete{m})
   }

   render() =
      .shard %
         @state.messages each m ->
            active = m.channel === @state.focus
            result =
               div %
                  ;; key = m.message-id
                  className = if{active, "active-message", "inactive-message"}
                  Message %
                     active = active
                     message = m
            result
