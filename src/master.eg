
require:
   events -> EventEmitter
   node-uuid as uuid
   .utilities ->
      is-channel
      get-channel
      get-network
   .messages ->
      message-transformers
      message-mergers
   .shard ->
      Shardset

provide:
   Channel
   View2
   Dispatcher2


var __id = 0
next-id() =
   __id += 1


class Channel < EventEmitter:

   constructor(@master, full-name, @transformers, @mergers) =
      @id = uuid()
      @set-max-listeners(0)
      @_rename(full-name)
      @nickname = null
      @users = {=}
      @messages = {}

   ;; What goes here

   accepts(m) =
      ;; match @matcher:
      ;;    null? ->
      ;;       m.channel === @full-name
      ;;    RegExp? ->
      ;;       @matcher? m.channel
      ;;    else ->
      ;;       throw E.bad-matcher(@matcher)
      m.channel === @full-name

   ;; Channel name

   _rename(@full-name) =
      @network = get-network(@full-name)
      @short-name = get-channel(@full-name)

   rename(new-full-name) =
      @_rename(new-full-name)
      @emit(.rename, new-full-name)

   ;; Own nickname

   set-nickname(new-name) =
      @emit(.set-nickname, @nickname, new-name)
      @nickname = new-name

   ;; Users

   delete-user(name) =
      if @users[name] as u:
         @emit(.delete-users, {u})
         delete @users[name]

   add-user(name, u) =
      @users[name] = u
      @emit(.add-users, {u})

   with-user(_name, fn) =
      name = _name or "#"
      u = @users[name] or {
         nickname = name
         modes = new Set()
      }
      match fn(u):
         false? ->
            @delete-user(name)
         u when u.nickname !== name ->
            @delete-user(name)
            @add-user(u.nickname, u)
            if name === @short-name:
               @rename(u.nickname)
         u ->
            @add-user(name, u)

   ;; Messages

   update-from-message(m) =
      ;; channel = m.channel
      match m.type:

         .nick ->
            if not m.from or m.from === @nickname:
               @set-nickname(m.to)
            @with-user(m.from) with u ->
               u & {nickname = m.to}

         .names ->
            to-delete = new Set with keys(@users)
            items(m.content) each {nickname, data} ->
               to-delete.delete(nickname)
               @with-user(nickname) with u ->
                  s = u.modes
                  data.operator-level each
                     "~" -> s.add("q")
                     "&" -> s.add("a")
                     "@" -> s.add("o")
                     "%" -> s.add("h")
                     "+" -> s.add("v")
                     other -> pass
                  u
            to-delete each name ->
               @delete-user(name)

         .join ->
            @with-user(m.agent) with u -> u
            if m.self:
               @set-nickname(m.agent)

         .part or .quit ->
            @delete-user(m.agent)

         .add-mode when R"[vhoaq]"? m.mode ->
            @with-user(m.argument) with u ->
               ;; TODO: make functional
               u.modes.add(m.mode)
               u

         .remove-mode when R"[vhoaq]"? m.mode ->
            @with-user(m.argument) with u ->
               ;; TODO: make functional
               u.modes.delete(m.mode)
               u

         else ->
            return

   ;; Transform and merge

   transform-message(m) =
      loopy(m) =
         fn = @transformers[m.type] or @transformers._other
         m2 = fn.call(@, m)
         if not m2:
            null
         elif m2 === .reject:
            .reject
         elif m2 === true or m === m2:
            m
         else:
            loopy(m2)
      result = loopy(m)
      if result === .reject:
         return null
      if not result:
         return result
      {.time, .channel} each field ->
         result[field] = m[field]
      result.start-time and result.end-time = result.time
      result.message-id = uuid()
      result.seq-id = next-id()
      result

   merge-messages(m1, m2) =
      if m1.type !== m2.type or m1.channel !== m2.channel:
         return {m1, m2}
      fn = @mergers[m1.type] or @mergers._other
      m3 = fn.call(@, m1, m2)
      if not m3:
         {m1, m2}
      else:
         m3.message-id = uuid()
         m3.seq-id = next-id()
         m3.start-time = m1.start-time or m1.time
         m3.end-time = m2.end-time or m2.time
         if not m3.time:
            m3.time = m2.time
         {m3}

   ;; Message stream

   append-message(m) =
      @messages.push(m)
      @emit(.add-messages, {m})

   insert-message(m, i) =
      @messages.splice(i, 0, m)
      @emit(.add-messages, {m})

   delete-message(i) =
      @emit(.delete-messages, @messages.splice(i, 1))

   find-latch(m) =
      ;; This can be used to make slight adjustments to message order
      ;; by not necessarily merging a message with the very latest
      if @messages.length === 0:
         null
      else:
         @messages.length - 1

   incorporate-message(m, orig = @messages.length) =
      idx = @find-latch(m)
      if idx !== null:
         m2 = @messages[idx]
         match @merge-messages(m2, m):
            {_, _} ->
               @insert-message(m, orig)
            {nm} ->
               @delete-message(idx)
               @incorporate-message(nm, idx)
      else:
         @insert-message(m, orig)

   ;; Processing a message

   process-message(m) =
      m2 = @transform-message(m)
      if m2:
         @incorporate-message(m2)
         @update-from-message(m)

   process-messages(ms) =
      ms each m ->
         @process-message(m)

   ;; Sending

   send(m) =
      ;; if @matcher:
      ;;    throw E.cannot-send(@full-name)
      ;; else:
      m.channel = @full-name
      @master.send(m)



class View2 < EventEmitter:

   constructor(@master, @label = null, @matcher = null) =
      @id = uuid()
      @set-max-listeners(0)
      @channels = new Set()
      @focus = null
      @nickname = null

      ;; Event handlers to install on focus
      @focus-event-handlers = {
         set-nickname(old, new) =
            @emit(.set-nickname, old, new)
            @nickname = new
      }

      @general-event-handlers = {
         add-messages(ms) =
            ;; TODO: error handling
            @shardset.add-all(ms)
            @emit(.add-messages, ms)
         delete-messages(ms) =
            ;; TODO: error handling
            @shardset.delete-all(ms)
            @emit(.delete-messages, ms)
      }

      @shardset = Shardset(adapter, 20) where adapter = {
         key(m) =
            m.start-time
         low(m) =
            m.start-time
         high(m) =
            m.start-time
         compare(m1, m2) =
            if m1.start-time < m2.start-time:
               -1
            elif m1.start-time > m2.start-time:
               1
            elif m1.seq-id < m2.seq-id:
               -1
            elif m1.seq-id > m2.seq-id:
               1
            else:
               0
      }

   set-label(new-label) =
      @emit(.set-label, @label, new-label)
      @label = new-label

   accepts(channel) =
      match @matcher:
         null? -> false
         RegExp? r -> r? channel.full-name
         Array? a -> a.index-of(channel.full-name) !== -1

   empty() =
      @channels.size === 0

   unset-focus() =
      if @focus:
         items(@focus-event-handlers) each {name, fn} ->
            @focus.remove-listener(name, fn)
      @nickname and @focus = null

   set-focus(channel) =
      if @focus === channel:
         return
      @emit(.set-focus, @focus, channel)
      @unset-focus()
      if channel:
         items(@focus-event-handlers) each {name, fn} ->
            channel.on(name, fn)
         @focus = channel
         @emit(.set-nickname, null, @focus.nickname)
         @nickname = @focus.nickname

   add-channel(channel) =
      @emit(.add-channel, channel)
      items(@general-event-handlers) each {name, fn} ->
         channel.on(name, fn)
      @channels.add(channel)
      @emit(.add-messages, channel.messages)
      @shardset.add-all(channel.messages)
      if @focus === null:
         @set-focus(channel)

   remove-channel(channel) =
      @emit(.remove-channel, channel)
      items(@general-event-handlers) each {name, fn} ->
         channel.remove-listener(name, fn)
      @emit(.delete-messages, channel.messages)
      @shardset.delete-all(channel.messages)
      @channels.remove(channel)
      if @focus === channel:
         @set-focus(null)

   send(m) =
      @focus.send(m)


class Dispatcher2 < EventEmitter:

   constructor(@source) =
      @id = uuid()
      @set-max-listeners(0)
      @channels = {=}
      @views = {}
      @focus = null
      set-interval(fn, 1000) where fn() =
         @emit(.tick)

   set-focus(@focus) =
      @emit(.set-focus, @focus)

   view-trigger(m) =
      m.type in {.join, .message, .action, .motd}

   add-view(label = null, matcher = null) =
      view = View2(@, label, matcher)
      items(@channels) each {_, ch} ->
         if view.accepts(ch):
            view.add-channel(ch)
      @emit(.add-view, view)
      @views.push(view)
      if @focus === null:
         @set-focus(view)
      view

   open-channel(channel, m = null) =
      if not @channels[channel]:
         ch = Channel(@, channel, message-transformers, message-mergers)
         @channels[channel] = ch
         targets = @views each v when v.accepts(ch) -> v
         if targets.length === 0:
            if not m or @view-trigger(m):
               view = @add-view(null)
               view.add-channel(ch)
            elif ch.transform-message(m) as m2:
               @emit(.unattached-message, m2)
         else:
            targets each v ->
               v.add-channel(ch)
      @channels[channel]

   process(new-message) =
      if not new-message:
         return null
      ch = @open-channel(new-message.channel, new-message)
      ch.process-message(new-message)

   send(message) =
      @source.send(message)

   async run() =
      while true:
         m = await @source.next()
         if m === null or m === undefined:
            break
         m.message-id = uuid()
         m.seq-id = next-id()
         @process(m)

