
require:
   lodash
   moment

provide:
   is-channel
   compute-level
   get-channel
   get-network
   mom
   shorten
   SortedArray

mom(d) =
   moment(d, "YYYY-MM-DD hh:mm:ss")

shorten(channel) =
   get-channel(channel) or get-network(channel)

get-network(channel) =
   channel.split("/")[... -1].join("/")

get-channel(channel) =
   parts = channel.split("/")
   parts[parts.length - 1]

is-channel(channel) =
   channel.match(R"^[#&~!]")

compute-level(modes) =
   m = lodash.max with modes each
      "q" -> 5
      "a" -> 4
      "o" -> 3
      "h" -> 2
      "v" -> 1
      else -> 0
   m or 0

space-mapping = {
   "0" => "\u2001"
   "1" => "\u2002"
   "2" => "\u2003"
   "3" => "\u2004"
   "4" => "\u2005"
   "5" => "\u2006"
   "6" => "\u2007"
   "7" => "\u2008"
   "8" => "\u2009"
   "9" => "\u200A"
   "A" => "\u200B"
   "B" => "\u200C"
   "C" => "\u200D"
   "D" => "\u202F"
   "E" => "\u205F"
   "F" => "\u3000"
}

reverse-space-mapping = object with
   items(space-mapping) each {k, v} -> {v, k}

space-code(s) =
   (s.to-upper-case() each c -> space-mapping[c] or "?").join("")

parse-space-code(s) =
   var result = ""
   s each c ->
      c2 = reverse-space-mapping[c]
      if c2 === undefined:
         return false
      result += c2
   result


findInsert(xs, x) =
   var lo = 0
   var hi = xs.length - 1
   while lo <= hi:
      mid = lo + ((hi - lo) // 2)
      match xs[mid]:
         < x  -> lo = mid + 1
         > x  -> hi = mid - 1
         else -> return {mid, true}
   {lo, false}


class SortedArray:

   constructor(@key-function, @duplicate-keys = true) =
      @_arr = {}
      @_keys = {}

   populate(elements) =
      @_arr = lodash.sort-by(elements, @key-function)
      @_keys = lodash.sort-by(elements.map(@key-function))
      @

   add-all(elements) =
      elements each element ->
         @add(element)
      @

   add(element) =
      key = @key-function(element)
      {idx, found} = @_find-key-index(key)
      if not found or @duplicate-keys:
         @_keys.splice(idx, 0, key)
         @_arr.splice(idx, 0, element)
      else:
         @_keys[idx] = key
         @_arr[idx] = element
      @

   .delete(element) =
      key = @key-function(element)
      {idx, found} = @_find-key-index(key)
      if found:
         @_keys.splice(idx, 1)
         @_arr.splice(idx, 1)
      else:
         throw E.element-not-found('Element could not be deleted because it could not be found: {element}')
      @

   delete-all(elements) =
      elements each element ->
         @delete(element)
      @

   find-index(element) =
      @_find-key-index(@key-function(element))[0]

   _find-key-index(key) =
      find-insert(@_keys, key)

   gen [^Symbol.iterator]() =
      @_arr each x -> yield x
